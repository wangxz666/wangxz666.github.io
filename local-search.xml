<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/30/%E5%BC%82%E6%AD%A5/"/>
    <url>/2021/03/30/%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>回调函数</strong>：一个函数作为参数传给另一个函数，作为参数的这个函数就叫回调函数</p><p>回调地狱</p><p>​                $.ajax({    url:url1,    data:data1,    success:function (rtData1) {        $.ajax({            url:url2,            data:rtData1,            success:function (rtData2) {             }        })    } })              </p><p><strong>Promise</strong>：链式调用</p><p>​                new Promise((resolve,reject)=&gt;{    $.ajax({        url:url1,        data:data1,        success:function (reData1) {            resolve(reData1)        },fail:function(data){                   reject(data))         })    }) })).then(value=&gt;{     }value =&gt; {    $.ajax({        url:url2,        data:value,        success:function (reData2) {         }    }) },})              </p><p><strong>Promise链式调用原理</strong>：</p><p>then中的两个函数就是对应resolve，reject两个函数</p><p>​                new Promise(function (resolve,reject) {    resolve(1)    //reject(2)) }).then(function (value) {    console.log(value); },function (value) {    console.log(value); })              </p><p>1、成功回调：resolve  return   失败回调：reject  throw Error</p><p>2、步骤1中的reject只影响步骤2的方法调用，虽然步骤2执行失败回调方法但是return成功了所以步骤三中依然执行成功回调</p><p>​                new Promise((resolve,reject)=&gt;{    reject(1)    // 步骤1 }).then(value =&gt; {    console.log(value);    return 2 },value =&gt; {    // 步骤2    console.log(value);     return 2 }).then(value =&gt; {    //步骤3    return new Promise(resolve =&gt; {        setTimeout(()=&gt;{            console.log(value);            resolve(3)        },1000)    }) }).then(value =&gt; {    console.log(value); })              </p><p><strong>宏任务（后运行）和微任务（先运行）：</strong></p><p><strong>宏任务</strong>：1. script (可以理解为外层同步代码)   2. setTimeout/setInterval  3. UI rendering/UI事件  4. postMessage，MessageChannel  5. setImmediate，I/O（Node.js）</p><p><strong>微任务：</strong>1. Promise  2. MutaionObserver  3. process.nextTick（Node.js）</p><p>JS引擎常驻于内存中，等待宿主将JS代码或函数传递给它。也就是等待<strong>宿主环境分配宏观任务，反复等待 - 执行</strong>即为事件循环。</p><p>Event Loop中，每一次循环称为tick，每一次tick的任务如下：</p><ul><li>执行栈选择最先进入队列的宏任务（一般都是script），执行其同步代码直至结束；</li><li>检查是否存在微任务，有则会执行至微任务队列为空；</li><li>如果宿主为浏览器，可能会渲染页面；</li><li>开始下一轮tick，执行宏任务中的异步代码（setTimeout等回调）</li></ul><p>​                new Promise((resolve)=&gt;{    console.log(‘a’)    resolve() }).then(()=&gt;{    console.log(‘b’) }) console.log(‘c’); setTimeout(()=&gt;{    console.log(‘d’); },0) console.log(‘e’);              </p><p>​                输出：a c e b d              </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/23/prototype/"/>
    <url>/2021/03/23/prototype/</url>
    
    <content type="html"><![CDATA[<p><strong>原型：</strong></p><p>①所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象</p><p>②所有函数都有一个prototype(原型)属性，属性值是一个普通的对象</p><p>③所有引用类型的__proto__属性指向它构造函数的prototype</p><p><strong>原型链</strong>：</p><p>当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。</p><p>为什么使用原型？</p><p><strong>方法写在原型中比写在构造函数中消耗内存小，因为在内存中一个类的原型只有一个，写在原型中的行为可以被所有实例共享，实例化的时候并不会在实例内存中再复制一份。而写在类的方法，在实例化的时候都会复制一份，所以消耗的内存更高。</strong></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> foo();<br></code></pre></td></tr></table></figure><p>这里创建了一个对象a，是foo的一个实例。既然a是一个对象，它就有原型__proto__，那a的__proto__是怎么设定的？这里就引出了prototype，它是<strong>函数</strong>才有的一个属性，也是一个对象，一个函数创建的实例的__proto__就指向这个函数的prototype。所以a的__proto__被设定为foo.prototype，即：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a.__proto__</span> === foo.prototype<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>当然foo.prototype也是个对象，它自然也有__proto__，默认指向Object.prototype，即：   </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">foo.prototype.__proto__</span> === Object.prototype<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>而Object.prototype已经没有原型了，它的__proto__是null。这是JavaScript里一个很特殊的对象，它就是原型链的顶端。</strong></p><p><strong>以上就构成了由对象a开始的原型链：</strong>     </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a.__proto__</span> === foo.prototype<span class="hljs-comment">; </span><br><span class="hljs-attr">a.__proto__.__proto__</span> === Object.prototype<span class="hljs-comment">;        </span><br></code></pre></td></tr></table></figure><p>JavaScript因此而推断出：          </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">a <span class="hljs-keyword">instanceof</span> foo === <span class="hljs-literal">true</span>; <br>a <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> === <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>​      <img src="/image/prototype.png" alt="prototype"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/17/uni-app/"/>
    <url>/2021/03/17/uni-app/</url>
    
    <content type="html"><![CDATA[<p>通过vue-cli创建uni-app</p><p>1、全局安装vue-cli</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g @vue/cli<br></code></pre></td></tr></table></figure><p>2、创建uni-app</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">vue create -p dcloudio/uni-preset-vue <span class="hljs-keyword">my</span>-project<br></code></pre></td></tr></table></figure><p>3、选择项目模板</p><p><img src="/image/cmd.png" alt="cmd"></p><p>4、打包</p><p>打包成h5:npm run build:h5</p><p>打包微信小程序：npm run build:mp-weixin  用微信开发者工具打开打包后的文件</p><p>打包app：</p><p>a、在开发者中心（<a href="https://dev.dcloud.net.cn/app/index?type=0%EF%BC%89%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%EF%BC%8C%E7%94%9F%E6%88%90appId">https://dev.dcloud.net.cn/app/index?type=0）创建应用，生成appId</a></p><p>b、在manifest.json配置生成的appId</p><p>c、用Hbuilder工具生成原生app安装包</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
