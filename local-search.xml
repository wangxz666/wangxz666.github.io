<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/30/%E5%BC%82%E6%AD%A5/"/>
    <url>/2021/03/30/%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>回调函数</strong>：一个函数作为参数传给另一个函数，作为参数的这个函数就叫回调函数</p><p>回调地狱 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript">$.ajax(&#123;<br>    url:url1,<br>    data:data1,<br>    success:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rtData1</span>) </span>&#123;<br>        $.ajax(&#123;<br>            url:url2,<br>            data:rtData1,<br>            success:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rtData2</span>) </span>&#123;<br><br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>​         </p><p><strong>Promise</strong>：链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    $.ajax(&#123;<br>        url:url1,<br>        data:data1,<br>        success:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reData1</span>) </span>&#123;<br>            resolve(reData1)<br>        &#125;,<span class="hljs-attr">fail</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>                   reject(data)) <br>        &#125;)<br>    &#125;)<br>&#125;)).then(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <br>&#125;value =&gt; &#123;<br>    $.ajax(&#123;<br>        url:url2,<br>        data:value,<br>        success:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reData2</span>) </span>&#123;<br><br>        &#125;<br>    &#125;)<br>&#125;,&#125;)<br></code></pre></td></tr></table></figure><p><strong>Promise链式调用原理</strong>：</p><p>then中的两个函数就是对应resolve，reject两个函数    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve,reject</span>) </span>&#123;<br>    resolve(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">//reject(2))</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>&#125;)<br></code></pre></td></tr></table></figure><p>1、成功回调：resolve  return   失败回调：reject  throw Error</p><p>2、步骤1中的reject只影响步骤2的方法调用，虽然步骤2执行失败回调方法但是return成功了所以步骤三中依然执行成功回调        </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    reject(<span class="hljs-number">1</span>)    <span class="hljs-comment">// 步骤1</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;,<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<span class="hljs-comment">// 步骤2</span><br>    <span class="hljs-built_in">console</span>.log(value); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<span class="hljs-comment">//步骤3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(value);<br>            resolve(<span class="hljs-number">3</span>)<br>        &#125;,<span class="hljs-number">1000</span>)<br>    &#125;)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>宏任务（后运行）和微任务（先运行）：</strong></p><p><strong>宏任务</strong>：1. script (可以理解为外层同步代码)   2. setTimeout/setInterval  3. UI rendering/UI事件  4. postMessage，MessageChannel  5. setImmediate，I/O（Node.js）</p><p><strong>微任务：</strong>1. Promise  2. MutaionObserver  3. process.nextTick（Node.js）</p><p>JS引擎常驻于内存中，等待宿主将JS代码或函数传递给它。也就是等待<strong>宿主环境分配宏观任务，反复等待 - 执行</strong>即为事件循环。</p><p>Event Loop中，每一次循环称为tick，每一次tick的任务如下：</p><ul><li>执行栈选择最先进入队列的宏任务（一般都是script），执行其同步代码直至结束；</li><li>检查是否存在微任务，有则会执行至微任务队列为空；</li><li>如果宿主为浏览器，可能会渲染页面；</li><li>开始下一轮tick，执行宏任务中的异步代码（setTimeout等回调） </li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span>)<br>    resolve()<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;c&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;d&#x27;</span>);<br>&#125;,<span class="hljs-number">0</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;e&#x27;</span>);<br></code></pre></td></tr></table></figure><p>​    输出：a c e b d              </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/23/prototype/"/>
    <url>/2021/03/23/prototype/</url>
    
    <content type="html"><![CDATA[<p><strong>原型：</strong></p><p>①所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象</p><p>②所有函数都有一个prototype(原型)属性，属性值是一个普通的对象</p><p>③所有引用类型的__proto__属性指向它构造函数的prototype</p><p><strong>原型链</strong>：</p><p>当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。</p><p>为什么使用原型？</p><p><strong>方法写在原型中比写在构造函数中消耗内存小，因为在内存中一个类的原型只有一个，写在原型中的行为可以被所有实例共享，实例化的时候并不会在实例内存中再复制一份。而写在类的方法，在实例化的时候都会复制一份，所以消耗的内存更高。</strong></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> foo();<br></code></pre></td></tr></table></figure><p>这里创建了一个对象a，是foo的一个实例。既然a是一个对象，它就有原型__proto__，那a的__proto__是怎么设定的？这里就引出了prototype，它是<strong>函数</strong>才有的一个属性，也是一个对象，一个函数创建的实例的__proto__就指向这个函数的prototype。所以a的__proto__被设定为foo.prototype，即：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a.__proto__</span> === foo.prototype<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>当然foo.prototype也是个对象，它自然也有__proto__，默认指向Object.prototype，即：   </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">foo.prototype.__proto__</span> === Object.prototype<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>而Object.prototype已经没有原型了，它的__proto__是null。这是JavaScript里一个很特殊的对象，它就是原型链的顶端。</strong></p><p><strong>以上就构成了由对象a开始的原型链：</strong>     </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a.__proto__</span> === foo.prototype<span class="hljs-comment">; </span><br><span class="hljs-attr">a.__proto__.__proto__</span> === Object.prototype<span class="hljs-comment">;        </span><br></code></pre></td></tr></table></figure><p>JavaScript因此而推断出：          </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">a <span class="hljs-keyword">instanceof</span> foo === <span class="hljs-literal">true</span>; <br>a <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> === <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>​      <img src="/image/prototype.png" alt="prototype"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/17/uni-app/"/>
    <url>/2021/03/17/uni-app/</url>
    
    <content type="html"><![CDATA[<p>通过vue-cli创建uni-app</p><p>1、全局安装vue-cli</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g @vue/cli<br></code></pre></td></tr></table></figure><p>2、创建uni-app</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">vue create -p dcloudio/uni-preset-vue <span class="hljs-keyword">my</span>-project<br></code></pre></td></tr></table></figure><p>3、选择项目模板</p><p><img src="/image/cmd.png" alt="cmd"></p><p>4、打包</p><p>打包成h5:npm run build:h5</p><p>打包微信小程序：npm run build:mp-weixin  用微信开发者工具打开打包后的文件</p><p>打包app：</p><p>a、在开发者中心（<a href="https://dev.dcloud.net.cn/app/index?type=0%EF%BC%89%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%EF%BC%8C%E7%94%9F%E6%88%90appId">https://dev.dcloud.net.cn/app/index?type=0）创建应用，生成appId</a></p><p>b、在manifest.json配置生成的appId</p><p>c、用Hbuilder工具生成原生app安装包</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
